<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Audio Tool</title>
  <link rel="icon"
    href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'><circle cx='16' cy='16' r='14' stroke='%233b9ea8' stroke-width='2.5' fill='none'/><path d='M12 10v12l10-6z' fill='%233b9ea8'/></svg>">
  <script src="https://cdn.jsdelivr.net/npm/lamejs@1.2.1/lame.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/libflacjs@5.4.0/dist/libflac.min.js"></script>
  <style>
    *,
    *::before,
    *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0
    }

    :root {
      --bg-dark: #0d0d12;
      --bg-panel: #14141c;
      --bg-surface: #1a1a24;
      --bg-elevated: #252532;
      --accent: #3b9ea8;
      --accent-dim: #2d7a82;
      --text: #e8e8f0;
      --text-dim: #7a7a8c;
      --danger: #ff4466;
      --warning: #ffaa00;
      --success: #4ade80;
      --selection: rgba(59, 158, 168, 0.25);
      --border: #2a2a3a
    }

    html,
    body {
      height: 100%;
      overflow: hidden;
      font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: var(--bg-dark);
      color: var(--text)
    }

    #app {
      display: flex;
      flex-direction: column;
      height: 100vh
    }

    header {
      background: linear-gradient(180deg, var(--bg-panel) 0%, var(--bg-surface) 100%);
      padding: 10px 18px;
      display: flex;
      align-items: center;
      gap: 14px;
      border-bottom: 1px solid var(--border);
      flex-shrink: 0
    }

    .logo {
      display: flex;
      align-items: center;
      gap: 8px
    }

    .logo svg {
      width: 28px;
      height: 28px
    }

    .logo h1 {
      font-size: 17px;
      font-weight: 700;
      background: linear-gradient(135deg, var(--accent), #5bc4ce);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent
    }

    .header-divider {
      width: 1px;
      height: 24px;
      background: var(--border)
    }

    .file-actions {
      display: flex;
      gap: 6px
    }

    .btn {
      background: var(--bg-elevated);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 7px 14px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
      font-weight: 500;
      transition: all 0.15s;
      display: flex;
      align-items: center;
      gap: 6px
    }

    .btn:hover {
      background: var(--bg-surface);
      border-color: var(--accent-dim)
    }

    .btn:active {
      transform: scale(0.98)
    }

    .btn.primary {
      background: linear-gradient(135deg, var(--accent), #4db8c4);
      color: #fff;
      border-color: transparent
    }

    .btn.primary:hover {
      opacity: 0.9
    }

    .btn:disabled {
      opacity: 0.4;
      cursor: not-allowed
    }

    .btn svg {
      width: 14px;
      height: 14px
    }

    .toolbar {
      display: flex;
      align-items: center;
      gap: 2px;
      flex: 1;
      flex-wrap: wrap
    }

    .tool-group {
      display: flex;
      align-items: center;
      gap: 2px;
      padding: 0 8px;
      border-right: 1px solid var(--border)
    }

    .tool-group:first-child {
      padding-left: 0
    }

    .tool-group:last-child {
      border-right: none
    }

    .tool-btn {
      width: 32px;
      height: 32px;
      border-radius: 6px;
      border: none;
      background: transparent;
      color: var(--text-dim);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      position: relative
    }

    .tool-btn:hover {
      background: var(--bg-elevated);
      color: var(--text)
    }

    .tool-btn.active {
      background: var(--accent);
      color: #fff
    }

    .tool-btn:disabled {
      opacity: 0.3;
      cursor: not-allowed
    }

    .tool-btn:disabled:hover {
      background: transparent
    }

    .tool-btn svg {
      width: 14px;
      height: 14px
    }

    .tooltip {
      position: absolute;
      top: 36px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--bg-dark);
      color: var(--text);
      padding: 4px 7px;
      border-radius: 4px;
      font-size: 10px;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.15s;
      z-index: 100;
      border: 1px solid var(--border)
    }

    .tool-btn:hover .tooltip,
    .tool-btn:focus .tooltip,
    .transport-btn:hover .tooltip,
    .transport-btn:focus .tooltip {
      opacity: 1
    }

    .tool-btn:focus,
    .transport-btn:focus,
    .zoom-btn:focus,
    .volume-btn:focus,
    .btn:focus {
      outline: 2px solid var(--accent);
      outline-offset: 2px
    }

    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0
    }

    .main-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0
    }

    .waveform-container {
      flex: 1;
      background: var(--bg-surface);
      display: flex;
      flex-direction: column;
      position: relative;
      min-height: 0
    }

    .timeline-ruler {
      height: 28px;
      background: var(--bg-panel);
      border-bottom: 1px solid var(--border);
      position: relative;
      flex-shrink: 0
    }

    .timeline-ruler canvas {
      width: 100%;
      height: 100%
    }

    .waveform-area {
      flex: 1;
      position: relative;
      min-height: 0
    }

    .waveform-area.audio-loaded {
      cursor: crosshair
    }

    #waveformCanvas {
      width: 100%;
      height: 100%;
      display: block
    }

    .playhead {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 2px;
      background: #fff;
      pointer-events: none;
      z-index: 10;
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.5)
    }

    .selection-overlay {
      position: absolute;
      top: 0;
      bottom: 0;
      background: var(--selection);
      border-left: 2px solid var(--accent);
      border-right: 2px solid var(--accent);
      pointer-events: none;
      z-index: 5
    }

    .bottom-panel {
      background: var(--bg-panel);
      border-top: 1px solid var(--border);
      display: flex;
      align-items: stretch;
      flex-shrink: 0
    }

    .time-section {
      display: flex;
      align-items: center;
      padding: 10px 18px;
      border-right: 1px solid var(--border);
      gap: 8px
    }

    .time-current {
      font-family: 'SF Mono', 'Fira Code', monospace;
      font-size: 20px;
      font-weight: 600;
      color: #fff;
      letter-spacing: -0.5px
    }

    .time-separator {
      color: var(--text-dim);
      font-size: 15px;
      margin: 0 2px
    }

    .time-total {
      font-family: 'SF Mono', 'Fira Code', monospace;
      font-size: 13px;
      color: var(--text-dim)
    }

    .controls-section {
      display: flex;
      align-items: center;
      gap: 16px;
      padding: 10px 16px
    }

    .transport {
      display: flex;
      align-items: center;
      gap: 4px
    }

    .transport-btn {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      border: none;
      background: var(--bg-elevated);
      color: var(--text);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      position: relative
    }

    .transport-btn:hover {
      background: #3a3a4a;
      transform: scale(1.05)
    }

    .transport-btn.play-btn {
      background: #3a3a4a
    }

    .transport-btn.play-btn:hover {
      background: #454558
    }

    .transport-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
      transform: none
    }

    .transport-btn:disabled:hover {
      transform: none;
      background: var(--bg-elevated)
    }

    .transport-btn.active {
      background: var(--accent);
      color: #fff
    }

    .transport-btn svg {
      width: 16px;
      height: 16px
    }

    .transport-btn .tooltip {
      left: 50%;
      top: -30px
    }

    .control-group {
      display: flex;
      align-items: center;
      gap: 6px
    }

    .control-group label {
      font-size: 10px;
      color: var(--text-dim);
      font-weight: 500
    }

    .zoom-control {
      display: flex;
      align-items: center;
      background: var(--bg-dark);
      border-radius: 6px;
      padding: 2px;
      gap: 2px
    }

    .zoom-btn {
      width: 28px;
      height: 28px;
      border-radius: 4px;
      border: none;
      background: transparent;
      color: var(--text-dim);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      position: relative
    }

    .zoom-btn:hover {
      background: var(--bg-elevated);
      color: var(--text)
    }

    .zoom-btn svg {
      width: 15px;
      height: 15px
    }

    .zoom-btn .tooltip {
      position: absolute;
      top: -32px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--bg-dark);
      color: var(--text);
      padding: 4px 7px;
      border-radius: 4px;
      font-size: 10px;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.15s;
      z-index: 1000;
      border: 1px solid var(--border)
    }

    .zoom-btn:hover .tooltip {
      opacity: 1
    }

    .zoom-value {
      font-family: 'SF Mono', 'Fira Code', monospace;
      font-size: 12px;
      color: var(--text);
      min-width: 38px;
      text-align: center;
      padding: 0 5px
    }

    .slider {
      -webkit-appearance: none;
      appearance: none;
      height: 3px;
      background: var(--bg-dark);
      border-radius: 2px;
      outline: none
    }

    .slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 10px;
      height: 10px;
      background: #888;
      border-radius: 50%;
      cursor: pointer
    }

    .slider::-webkit-slider-thumb:hover {
      background: #aaa
    }

    .control-value {
      font-size: 10px;
      color: var(--text-dim);
      min-width: 28px
    }

    .volume-control {
      display: flex;
      align-items: center;
      background: var(--bg-dark);
      border-radius: 6px;
      padding: 2px;
      gap: 2px
    }

    .volume-btn {
      width: 28px;
      height: 28px;
      border-radius: 4px;
      border: none;
      background: transparent;
      color: var(--text-dim);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      position: relative
    }

    .volume-btn:hover {
      background: var(--bg-elevated);
      color: var(--text)
    }

    .volume-btn.muted {
      color: var(--danger)
    }

    .volume-btn svg {
      width: 14px;
      height: 14px
    }

    .volume-btn .tooltip {
      position: absolute;
      top: -32px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--bg-dark);
      color: var(--text);
      padding: 4px 7px;
      border-radius: 4px;
      font-size: 10px;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.15s;
      z-index: 1000;
      border: 1px solid var(--border)
    }

    .volume-btn:hover .tooltip {
      opacity: 1
    }

    .volume-value {
      font-family: 'SF Mono', 'Fira Code', monospace;
      font-size: 12px;
      color: var(--text);
      min-width: 40px;
      text-align: center;
      padding: 0 5px
    }

    .vu-section {
      display: flex;
      flex-direction: column;
      gap: 4px;
      padding: 8px 16px;
      border-left: 1px solid var(--border);
      flex: 1;
      min-width: 150px
    }

    .vu-meter {
      display: flex;
      align-items: center;
      gap: 6px
    }

    .vu-label {
      font-size: 9px;
      color: var(--text-dim);
      font-weight: 700;
      width: 10px
    }

    .vu-bar-container {
      flex: 1;
      height: 12px;
      background: var(--bg-dark);
      border-radius: 3px;
      position: relative;
      overflow: hidden;
      border: 1px solid var(--border)
    }

    .vu-bar {
      position: absolute;
      top: 1px;
      bottom: 1px;
      left: 1px;
      background: linear-gradient(90deg, #22c55e 0%, #22c55e 60%, #eab308 75%, #f97316 85%, #ef4444 95%);
      border-radius: 1px;
      transition: width 0.05s
    }

    .vu-peak {
      position: absolute;
      top: 1px;
      bottom: 1px;
      width: 2px;
      background: #fff;
      border-radius: 1px
    }

    .vu-scale {
      display: flex;
      justify-content: space-between;
      padding: 0 1px;
      margin-top: 1px
    }

    .vu-scale span {
      font-size: 7px;
      color: var(--text-dim)
    }

    .status-bar {
      background: var(--bg-dark);
      padding: 4px 14px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-size: 9px;
      color: var(--text-dim);
      border-top: 1px solid var(--border);
      flex-shrink: 0
    }

    .status-bar .info {
      display: flex;
      gap: 14px
    }

    .drop-zone {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.95);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000
    }

    .drop-zone.active {
      display: flex
    }

    .drop-zone-content {
      text-align: center;
      padding: 40px;
      border: 2px dashed var(--accent);
      border-radius: 14px
    }

    .drop-zone-content svg {
      width: 56px;
      height: 56px;
      color: var(--accent);
      margin-bottom: 14px
    }

    .drop-zone-content h2 {
      font-size: 18px;
      margin-bottom: 5px
    }

    .drop-zone-content p {
      color: var(--text-dim);
      font-size: 12px
    }

    .modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.85);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000
    }

    .modal.active {
      display: flex
    }

    .modal-backdrop {
      position: absolute;
      inset: 0
    }

    .modal-content {
      background: var(--bg-panel);
      border-radius: 10px;
      padding: 20px;
      width: 340px;
      border: 1px solid var(--border);
      position: relative;
      z-index: 1
    }

    .modal-content h3 {
      margin-bottom: 16px;
      font-size: 14px;
      font-weight: 600
    }

    .form-group {
      margin-bottom: 14px
    }

    .form-group label {
      display: block;
      font-size: 10px;
      color: var(--text-dim);
      margin-bottom: 6px;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.5px
    }

    .form-group input[type="text"] {
      width: 100%;
      padding: 8px 10px;
      background: var(--bg-dark);
      border: 1px solid var(--border);
      border-radius: 5px;
      color: var(--text);
      font-size: 12px
    }

    .form-group input[type="text"]:focus {
      outline: none;
      border-color: var(--accent)
    }

    .form-group fieldset {
      border: none;
      padding: 0;
      margin: 0
    }

    .form-group legend {
      font-size: 10px;
      color: var(--text-dim);
      margin-bottom: 6px;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.5px
    }

    .filename-input-group {
      display: flex;
      align-items: stretch;
      position: relative
    }

    .filename-input-group input {
      flex: 1;
      padding-right: 60px
    }

    .filename-ext {
      position: absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      color: var(--text-dim);
      font-size: 12px;
      font-family: 'SF Mono', 'Fira Code', monospace;
      pointer-events: none
    }

    .format-selector {
      display: inline-flex;
      align-items: center;
      background: var(--bg-dark);
      border-radius: 6px;
      padding: 2px;
      gap: 2px
    }

    .format-btn {
      padding: 6px 12px;
      border-radius: 4px;
      border: none;
      background: transparent;
      color: var(--text-dim);
      cursor: pointer;
      font-size: 11px;
      font-weight: 500;
      transition: all 0.15s
    }

    .format-btn:hover {
      background: var(--bg-elevated);
      color: var(--text)
    }

    .format-btn.active {
      background: var(--bg-elevated);
      color: var(--text)
    }

    .radio-group {
      display: flex;
      gap: 6px;
      flex-wrap: wrap
    }

    .radio-option {
      flex: 1;
      min-width: 60px
    }

    .radio-option input {
      display: none
    }

    .radio-option label {
      display: block;
      padding: 8px 10px;
      background: var(--bg-dark);
      border: 1px solid var(--border);
      border-radius: 5px;
      text-align: center;
      cursor: pointer;
      font-size: 11px;
      font-weight: 500;
      transition: all 0.15s
    }

    .radio-option input:checked+label {
      background: var(--bg-elevated);
      color: var(--text);
      border-color: transparent
    }

    .radio-option label:hover {
      background: var(--bg-elevated)
    }

    .range-group {
      display: flex;
      align-items: center;
      gap: 10px
    }

    .range-group input[type="range"] {
      flex: 1;
      -webkit-appearance: none;
      appearance: none;
      height: 5px;
      background: var(--bg-dark);
      border-radius: 3px
    }

    .range-group input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 14px;
      height: 14px;
      background: #888;
      border-radius: 50%;
      cursor: pointer
    }

    .range-group input[type="range"]::-webkit-slider-thumb:hover {
      background: #aaa
    }

    .range-value {
      font-size: 11px;
      color: var(--text);
      min-width: 45px;
      text-align: right;
      font-weight: 500
    }

    .modal-actions {
      display: flex;
      gap: 6px;
      justify-content: flex-end;
      margin-top: 18px
    }

    .empty-state {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: var(--text-dim);
      background: var(--bg-surface)
    }

    .empty-state svg {
      width: 48px;
      height: 48px;
      margin-bottom: 10px;
      opacity: 0.4;
      color: var(--accent)
    }

    .empty-state h3 {
      font-size: 14px;
      margin-bottom: 5px;
      color: var(--text)
    }

    .empty-state p {
      font-size: 11px;
      margin-bottom: 14px
    }

    .empty-state .empty-buttons {
      display: flex;
      gap: 8px
    }

    input[type="file"] {
      display: none
    }

    .selection-marker {
      position: absolute;
      top: 0;
      padding: 2px 4px;
      font-size: 8px;
      font-family: 'SF Mono', monospace;
      background: var(--accent);
      color: #fff;
      border-radius: 0 0 3px 3px;
      transform: translateX(-50%);
      z-index: 20;
      white-space: nowrap;
      pointer-events: none
    }

    .silence-options {
      display: flex;
      flex-direction: column;
      gap: 14px
    }

    .btn.recording {
      background: var(--danger);
      border-color: var(--danger);
      color: #fff;
      animation: pulse-record 1s infinite
    }

    @keyframes pulse-record {

      0%,
      100% {
        opacity: 1;
      }

      50% {
        opacity: 0.5;
      }
    }

    .recording-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.9);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      gap: 24px
    }

    .recording-indicator {
      display: flex;
      align-items: center;
      gap: 20px
    }

    .recording-circle {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: var(--danger);
      animation: pulse-record 1s infinite;
      box-shadow: 0 0 20px rgba(255, 68, 102, 0.5)
    }

    .recording-timer {
      font-family: 'SF Mono', 'Fira Code', monospace;
      font-size: 48px;
      font-weight: 600;
      color: #fff;
      letter-spacing: -1px
    }

    .modal-content.wide {
      width: 420px
    }

    .github-link {
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-dim);
      transition: color 0.15s;
      margin-left: auto
    }

    .github-link:hover {
      color: var(--text)
    }
  </style>
</head>

<body>
  <div id="app">
    <header>
      <div class="logo">
        <svg viewBox="0 0 32 32" fill="none">
          <circle cx="16" cy="16" r="14" stroke="var(--accent)" stroke-width="2.5" fill="none" />
          <path d="M12 10v12l10-6z" fill="var(--accent)" />
        </svg>
        <h1>Audio Tool</h1>
      </div>
      <div class="header-divider"></div>
      <div class="file-actions">
        <button class="btn" id="importBtn"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M12 3v12m0 0l-4-4m4 4l4-4" />
            <path d="M3 15v4a2 2 0 002 2h14a2 2 0 002-2v-4" />
          </svg>Import</button>
        <button class="btn" id="exportBtn" disabled><svg viewBox="0 0 24 24" fill="none" stroke="currentColor"
            stroke-width="2">
            <path d="M12 15V3m0 0l4 4m-4-4L8 7" />
            <path d="M3 15v4a2 2 0 002 2h14a2 2 0 002-2v-4" />
          </svg>Export</button>
      </div>
      <div class="header-divider"></div>
      <div class="toolbar">
        <div class="tool-group">
          <button class="tool-btn" id="undoTool" data-action="undo" disabled><svg viewBox="0 0 24 24" fill="none"
              stroke="currentColor" stroke-width="2">
              <path d="M3 10h10a5 5 0 015 5v2" />
              <path d="M3 10l5 5M3 10l5-5" />
            </svg><span class="tooltip">Undo</span></button>
          <button class="tool-btn" id="redoTool" data-action="redo" disabled><svg viewBox="0 0 24 24" fill="none"
              stroke="currentColor" stroke-width="2">
              <path d="M21 10H11a5 5 0 00-5 5v2" />
              <path d="M21 10l-5 5M21 10l-5-5" />
            </svg><span class="tooltip">Redo</span></button>
        </div>
        <div class="tool-group">
          <button class="tool-btn" id="cutTool" data-action="cut" disabled><svg viewBox="0 0 24 24" fill="none"
              stroke="currentColor" stroke-width="2">
              <circle cx="6" cy="6" r="3" />
              <circle cx="6" cy="18" r="3" />
              <path d="M20 4L8.12 15.88M14.47 14.48L20 20M8.12 8.12L12 12" />
            </svg><span class="tooltip">Cut</span></button>
          <button class="tool-btn" id="copyTool" data-action="copy" disabled><svg viewBox="0 0 24 24" fill="none"
              stroke="currentColor" stroke-width="2">
              <rect x="9" y="9" width="13" height="13" rx="2" />
              <path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1" />
            </svg><span class="tooltip">Copy</span></button>
          <button class="tool-btn" id="pasteTool" data-action="paste" disabled><svg viewBox="0 0 24 24" fill="none"
              stroke="currentColor" stroke-width="2">
              <path d="M16 4h2a2 2 0 012 2v14a2 2 0 01-2 2H6a2 2 0 01-2-2V6a2 2 0 012-2h2" />
              <rect x="8" y="2" width="8" height="4" rx="1" />
            </svg><span class="tooltip">Paste</span></button>
          <button class="tool-btn" id="deleteTool" data-action="delete" disabled><svg viewBox="0 0 24 24" fill="none"
              stroke="currentColor" stroke-width="2">
              <path d="M3 6h18M8 6V4h8v2m1 0v14a2 2 0 01-2 2H9a2 2 0 01-2-2V6" />
            </svg><span class="tooltip">Delete</span></button>
          <button class="tool-btn" id="cropTool" data-action="crop" disabled><svg viewBox="0 0 24 24" fill="none"
              stroke="currentColor" stroke-width="2">
              <path d="M6 3v6M6 3H3M6 3h3M18 3v6M18 3h-3M18 3h3M6 21v-6M6 21H3M6 21h3M18 21v-6M18 21h-3M18 21h3" />
            </svg><span class="tooltip">Crop</span></button>
        </div>
        <div class="tool-group">
          <button class="tool-btn" id="fadeInTool" data-action="fadeIn" disabled><svg viewBox="0 0 24 24" fill="none"
              stroke="currentColor" stroke-width="2">
              <path d="M3 20c6-2 12-14 18-16" />
              <path d="M3 20h18" />
            </svg><span class="tooltip">Fade In</span></button>
          <button class="tool-btn" id="fadeOutTool" data-action="fadeOut" disabled><svg viewBox="0 0 24 24" fill="none"
              stroke="currentColor" stroke-width="2">
              <path d="M3 4c6 2 12 14 18 16" />
              <path d="M3 20h18" />
            </svg><span class="tooltip">Fade Out</span></button>
          <button class="tool-btn" id="normalizeTool" data-action="normalize" disabled><svg viewBox="0 0 24 24"
              fill="none" stroke="currentColor" stroke-width="2">
              <path d="M4 12h2l2-8 4 16 4-16 2 8h2" />
            </svg><span class="tooltip">Normalize</span></button>
          <button class="tool-btn" id="reverseTool" data-action="reverse" disabled><svg viewBox="0 0 24 24" fill="none"
              stroke="currentColor" stroke-width="2">
              <path d="M3 12h18M7 8l-4 4 4 4M17 8l4 4-4 4" />
            </svg><span class="tooltip">Reverse</span></button>
          <button class="tool-btn" id="silenceTool" data-action="silence" disabled><svg viewBox="0 0 24 24" fill="none"
              stroke="currentColor" stroke-width="2">
              <path d="M11 5L6 9H2v6h4l5 4V5z" />
              <line x1="22" y1="9" x2="16" y2="15" />
              <line x1="16" y1="9" x2="22" y2="15" />
            </svg><span class="tooltip">Silence</span></button>
          <button class="tool-btn" id="amplifyTool" data-action="amplify" disabled><svg viewBox="0 0 24 24" fill="none"
              stroke="currentColor" stroke-width="2">
              <path d="M11 5L6 9H2v6h4l5 4V5z" />
              <path d="M15 8l6 4-6 4" />
            </svg><span class="tooltip">Amplify</span></button>
          <button class="tool-btn" id="removeSilenceTool" data-action="removeSilence" disabled><svg viewBox="0 0 24 24"
              fill="none" stroke="currentColor" stroke-width="2">
              <path d="M4 12h16" />
              <path d="M9 6v12" />
              <path d="M15 6v12" />
              <line x1="2" y1="2" x2="22" y2="22" stroke-width="2.5" />
            </svg><span class="tooltip">Remove Silence</span></button>
        </div>
      </div>
      <a href="https://github.com/tcboni/audio-tool" target="_blank" class="github-link" title="View on GitHub">
        <svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20">
          <path
            d="M12 0C5.37 0 0 5.37 0 12c0 5.31 3.435 9.795 8.205 11.385.6.105.825-.255.825-.57 0-.285-.015-1.23-.015-2.235-3.015.555-3.795-.735-4.035-1.41-.135-.345-.72-1.41-1.23-1.695-.42-.225-1.02-.78-.015-.795.945-.015 1.62.87 1.845 1.23 1.08 1.815 2.805 1.305 3.495.99.105-.78.42-1.305.765-1.605-2.67-.3-5.46-1.335-5.46-5.925 0-1.305.465-2.385 1.23-3.225-.12-.3-.54-1.53.12-3.18 0 0 1.005-.315 3.3 1.23.96-.27 1.98-.405 3-.405s2.04.135 3 .405c2.295-1.56 3.3-1.23 3.3-1.23.66 1.65.24 2.88.12 3.18.765.84 1.23 1.905 1.23 3.225 0 4.605-2.805 5.625-5.475 5.925.435.375.81 1.095.81 2.22 0 1.605-.015 2.895-.015 3.3 0 .315.225.69.825.57A12.02 12.02 0 0024 12c0-6.63-5.37-12-12-12z" />
        </svg>
      </a>
    </header>
    <div class="main-content">
      <div class="waveform-container">
        <div class="timeline-ruler" id="timelineRuler"><canvas id="rulerCanvas" aria-hidden="true"></canvas></div>
        <div class="waveform-area" id="waveformArea" role="img"
          aria-label="Audio waveform. Click and drag to make a selection.">
          <canvas id="waveformCanvas" aria-hidden="true"></canvas>
          <div class="playhead" id="playhead" style="left:0;display:none"></div>
          <div class="selection-overlay" id="selection" style="display:none"></div>
          <div class="empty-state" id="emptyState">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
              <path d="M9 18V5l12-2v13" />
              <circle cx="6" cy="18" r="3" />
              <circle cx="18" cy="16" r="3" />
            </svg>
            <h3>No Audio Loaded</h3>
            <p>Import an audio file, record, or load a sample</p>
            <div class="empty-buttons">
              <button class="btn primary" id="emptyImportBtn">Import Audio</button>
              <button class="btn" id="recordBtn">Record</button>
              <button class="btn" id="loadSampleBtn">Load Sample</button>
            </div>
          </div>
        </div>
      </div>
      <div class="bottom-panel">
        <div class="time-section" role="timer" aria-label="Playback time">
          <span class="time-current" id="timeCurrent" aria-label="Current time">00:00.000</span>
          <span class="time-separator" aria-hidden="true">/</span>
          <span class="time-total" id="timeTotal" aria-label="Total duration">00:00.000</span>
        </div>
        <div class="controls-section">
          <div class="transport">
            <button class="transport-btn" id="skipStartBtn" disabled><svg viewBox="0 0 24 24" fill="currentColor">
                <path d="M6 6h2v12H6zm3.5 6l8.5 6V6z" />
              </svg><span class="tooltip">Start</span></button>
            <button class="transport-btn" id="rewindBtn" disabled><svg viewBox="0 0 24 24" fill="currentColor">
                <path d="M11 18V6l-8.5 6 8.5 6zm.5-6l8.5 6V6l-8.5 6z" />
              </svg><span class="tooltip">-5s</span></button>
            <button class="transport-btn play-btn" id="playBtn" disabled><svg viewBox="0 0 24 24" fill="currentColor"
                id="playIcon">
                <path d="M8 5v14l11-7z" />
              </svg><span class="tooltip">Play</span></button>
            <button class="transport-btn" id="stopBtn" disabled><svg viewBox="0 0 24 24" fill="currentColor">
                <rect x="6" y="6" width="12" height="12" rx="1" />
              </svg><span class="tooltip">Stop</span></button>
            <button class="transport-btn" id="forwardBtn" disabled><svg viewBox="0 0 24 24" fill="currentColor">
                <path d="M13 6v12l8.5-6L13 6zM4 18l8.5-6L4 6v12z" />
              </svg><span class="tooltip">+5s</span></button>
            <button class="transport-btn" id="skipEndBtn" disabled><svg viewBox="0 0 24 24" fill="currentColor">
                <path d="M6 18l8.5-6L6 6v12zM16 6h2v12h-2z" />
              </svg><span class="tooltip">End</span></button>
            <button class="transport-btn" id="loopBtn" disabled><svg viewBox="0 0 24 24" fill="none"
                stroke="currentColor" stroke-width="2">
                <path d="M17 2l4 4-4 4M3 11V9a4 4 0 014-4h14M7 22l-4-4 4-4M21 13v2a4 4 0 01-4 4H3" />
              </svg><span class="tooltip">Loop</span></button>
          </div>
          <div class="zoom-control">
            <button class="zoom-btn" id="zoomOutBtn" data-action="zoomOut"><svg viewBox="0 0 24 24" fill="none"
                stroke="currentColor" stroke-width="2">
                <path d="M21 21l-4-4" />
                <circle cx="11" cy="11" r="7" />
                <path d="M8 11h6" />
              </svg><span class="tooltip">Zoom Out (-)</span></button>
            <span class="zoom-value" id="zoomLevel">1.0x</span>
            <button class="zoom-btn" id="zoomInBtn" data-action="zoomIn"><svg viewBox="0 0 24 24" fill="none"
                stroke="currentColor" stroke-width="2">
                <path d="M21 21l-4-4" />
                <circle cx="11" cy="11" r="7" />
                <path d="M11 8v6M8 11h6" />
              </svg><span class="tooltip">Zoom In (+)</span></button>
          </div>
          <div class="volume-control">
            <button class="volume-btn" id="volumeDownBtn"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor"
                stroke-width="2">
                <path d="M11 5L6 9H2v6h4l5 4V5z" />
              </svg><span class="tooltip">Volume Down</span></button>
            <span class="volume-value" id="volumeLevel">100%</span>
            <button class="volume-btn" id="volumeUpBtn"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor"
                stroke-width="2">
                <path d="M11 5L6 9H2v6h4l5 4V5z" />
                <path d="M15.54 8.46a5 5 0 010 7.07" />
              </svg><span class="tooltip">Volume Up</span></button>
          </div>
        </div>
        <div class="vu-section">
          <div class="vu-meter">
            <span class="vu-label">L</span>
            <div class="vu-bar-container">
              <div class="vu-bar" id="vuLeft" style="width:0"></div>
              <div class="vu-peak" id="vuPeakLeft" style="left:0"></div>
            </div>
          </div>
          <div class="vu-meter">
            <span class="vu-label">R</span>
            <div class="vu-bar-container">
              <div class="vu-bar" id="vuRight" style="width:0"></div>
              <div class="vu-peak" id="vuPeakRight" style="left:0"></div>
            </div>
          </div>
          <div class="vu-scale">
            <span>-∞</span><span>-36</span><span>-24</span><span>-12</span><span>-6</span><span>0</span>
          </div>
        </div>
      </div>
    </div>
    <div class="status-bar">
      <div class="info"><span id="statusFile">No file</span><span id="statusSampleRate">—</span><span
          id="statusChannels">—</span><span id="statusDuration">—</span></div>
      <span id="statusMessage" role="status" aria-live="polite">Ready</span>
    </div>
  </div>
  <div class="drop-zone" id="dropZone">
    <div class="drop-zone-content"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
        <path d="M12 3v12m0 0l-4-4m4 4l4-4" />
        <path d="M3 15v4a2 2 0 002 2h14a2 2 0 002-2v-4" />
      </svg>
      <h2>Drop Audio File</h2>
      <p>MP3, WAV, OGG, FLAC</p>
    </div>
  </div>
  <div class="modal" id="exportModal" role="dialog" aria-labelledby="exportTitle" aria-modal="true">
    <div class="modal-backdrop"></div>
    <div class="modal-content">
      <h3 id="exportTitle">Export Audio</h3>
      <div class="form-group">
        <label for="exportFilename" id="filenameLabel">Filename</label>
        <div class="filename-input-group">
          <input type="text" id="exportFilename" value="audio-export" aria-labelledby="filenameLabel">
          <span class="filename-ext" id="filenameExt">.wav</span>
        </div>
      </div>
      <div class="form-group">
        <label>Format</label>
        <div class="format-selector" role="radiogroup" aria-label="Export format">
          <button type="button" class="format-btn active" data-format="wav">WAV</button>
          <button type="button" class="format-btn" data-format="mp3">MP3</button>
          <button type="button" class="format-btn" data-format="flac">FLAC</button>
        </div>
        <input type="hidden" name="format" id="selectedFormat" value="wav">
      </div>
      <div class="form-group" id="bitrateGroup" style="display:none">
        <label for="exportBitrate">Quality</label>
        <div class="range-group">
          <input type="range" id="exportBitrate" min="64" max="320" step="32" value="192" aria-valuemin="64"
            aria-valuemax="320" aria-valuenow="192">
          <span class="range-value" id="bitrateValue" aria-live="polite">192 kbps</span>
        </div>
      </div>
      <div class="modal-actions">
        <button class="btn" id="cancelExport">Cancel</button>
        <button class="btn primary" id="confirmExport">Export</button>
      </div>
    </div>
  </div>
  <div class="modal" id="amplifyModal" role="dialog" aria-labelledby="amplifyTitle" aria-modal="true">
    <div class="modal-backdrop"></div>
    <div class="modal-content">
      <h3 id="amplifyTitle">Amplify</h3>
      <div class="form-group">
        <label for="amplifySlider">Gain</label>
        <div class="range-group">
          <input type="range" id="amplifySlider" min="-20" max="20" value="0" step="0.5" aria-valuemin="-20"
            aria-valuemax="20" aria-valuenow="0">
          <span class="range-value" id="amplifyValue" aria-live="polite">0 dB</span>
        </div>
      </div>
      <div class="modal-actions">
        <button class="btn" id="cancelAmplify">Cancel</button>
        <button class="btn primary" id="confirmAmplify">Apply</button>
      </div>
    </div>
  </div>
  <div class="modal" id="silenceModal" role="dialog" aria-labelledby="silenceTitle" aria-modal="true">
    <div class="modal-backdrop"></div>
    <div class="modal-content">
      <h3 id="silenceTitle">Remove Silence</h3>
      <div class="silence-options">
        <div class="form-group">
          <label for="silenceThreshold">Threshold</label>
          <div class="range-group">
            <input type="range" id="silenceThreshold" min="-60" max="-20" value="-40" step="1">
            <span class="range-value" id="thresholdValue">-40 dB</span>
          </div>
        </div>
        <div class="form-group">
          <label for="silenceMinDuration">Min Silence Duration</label>
          <div class="range-group">
            <input type="range" id="silenceMinDuration" min="100" max="2000" value="500" step="100">
            <span class="range-value" id="minDurationValue">500 ms</span>
          </div>
        </div>
        <div class="form-group">
          <label for="silencePadding">Keep Padding</label>
          <div class="range-group">
            <input type="range" id="silencePadding" min="0" max="200" value="50" step="10">
            <span class="range-value" id="paddingValue">50 ms</span>
          </div>
        </div>
      </div>
      <div class="modal-actions">
        <button class="btn" id="cancelSilence">Cancel</button>
        <button class="btn primary" id="confirmSilence">Remove</button>
      </div>
    </div>
  </div>
  <input type="file" id="fileInput" accept="audio/*">
  <script>
    const MIN_SELECTION_MS = 50;
    class AudioTool {
      constructor() {
        this.audioContext = null; this.audioBuffer = null; this.sourceNode = null; this.gainNode = null;
        this.analyserL = null; this.analyserR = null; this.splitter = null;
        this.isPlaying = false; this.startTime = 0; this.playbackPosition = 0; this.playEndPosition = null;
        this.duration = 0; this.zoom = 1; this.scrollOffset = 0;
        this.selection = { start: null, end: null }; this.clipboard = null;
        this.isLooping = false; this.isSelecting = false;
        this.history = []; this.historyIndex = -1;
        this.peakL = 0; this.peakR = 0; this.peakDecay = 0.93;
        this.selectionMarkers = [];
        this.initElements(); this.initEvents(); this.initAudioContext();
        this.resizeCanvases(); this.animate();
      }
      initElements() {
        this.waveformCanvas = document.getElementById('waveformCanvas');
        this.waveformCtx = this.waveformCanvas.getContext('2d');
        this.rulerCanvas = document.getElementById('rulerCanvas');
        this.rulerCtx = this.rulerCanvas.getContext('2d');
        this.waveformArea = document.getElementById('waveformArea');
        this.timelineRuler = document.getElementById('timelineRuler');
        this.playhead = document.getElementById('playhead');
        this.selectionEl = document.getElementById('selection');
        this.emptyState = document.getElementById('emptyState');
        this.timeCurrent = document.getElementById('timeCurrent');
        this.timeTotal = document.getElementById('timeTotal');
        this.vuLeft = document.getElementById('vuLeft');
        this.vuRight = document.getElementById('vuRight');
        this.vuPeakLeft = document.getElementById('vuPeakLeft');
        this.vuPeakRight = document.getElementById('vuPeakRight');
        this.volumeLevel = document.getElementById('volumeLevel');
        this.volume = 1;
        this.fileInput = document.getElementById('fileInput');
        this.dropZone = document.getElementById('dropZone');
        this.exportModal = document.getElementById('exportModal');
        this.amplifyModal = document.getElementById('amplifyModal');
        this.silenceModal = document.getElementById('silenceModal');
        this.playBtn = document.getElementById('playBtn');
        this.loopBtn = document.getElementById('loopBtn');
        this.recordBtn = document.getElementById('recordBtn');
        this.isRecording = false;
        this.mediaRecorder = null;
        this.recordedChunks = [];
        this.stopRecordingBtn = null;
        this.recordingTimerInterval = null;
        this.recordingOverlay = null;
        this.recordingTimerEl = null;
        this.recordingSource = null;
        // Set aria-labels from tooltips for accessibility
        document.querySelectorAll('.tooltip').forEach(t => {
          const btn = t.parentElement;
          if (btn && !btn.getAttribute('aria-label')) {
            btn.setAttribute('aria-label', t.textContent);
          }
        });
      }
      initEvents() {
        window.addEventListener('resize', () => this.resizeCanvases());
        document.getElementById('importBtn').addEventListener('click', () => this.fileInput.click());
        document.getElementById('emptyImportBtn').addEventListener('click', () => this.fileInput.click());
        document.getElementById('loadSampleBtn').addEventListener('click', () => this.loadSample());
        document.getElementById('exportBtn').addEventListener('click', () => this.showExportModal());
        this.fileInput.addEventListener('change', (e) => this.handleFileSelect(e));
        document.body.addEventListener('dragover', (e) => { e.preventDefault(); this.dropZone.classList.add('active'); });
        document.body.addEventListener('dragleave', (e) => { if (e.target === this.dropZone) this.dropZone.classList.remove('active'); });
        document.body.addEventListener('drop', (e) => { e.preventDefault(); this.dropZone.classList.remove('active'); if (e.dataTransfer.files.length) this.loadFile(e.dataTransfer.files[0]); });
        this.playBtn.addEventListener('click', () => this.togglePlay());
        document.getElementById('stopBtn').addEventListener('click', () => this.stop());
        document.getElementById('skipStartBtn').addEventListener('click', () => this.skipToStart());
        document.getElementById('skipEndBtn').addEventListener('click', () => this.skipToEnd());
        document.getElementById('rewindBtn').addEventListener('click', () => this.seekRelative(-5));
        document.getElementById('forwardBtn').addEventListener('click', () => this.seekRelative(5));
        this.loopBtn.addEventListener('click', () => this.toggleLoop());
        document.getElementById('volumeDownBtn').addEventListener('click', () => this.adjustVolume(-0.1));
        document.getElementById('volumeUpBtn').addEventListener('click', () => this.adjustVolume(0.1));
        this.waveformArea.addEventListener('mousedown', (e) => this.onWaveformMouseDown(e));
        this.waveformArea.addEventListener('mousemove', (e) => this.onWaveformMouseMove(e));
        window.addEventListener('mouseup', (e) => this.onWaveformMouseUp(e));
        this.waveformArea.addEventListener('wheel', (e) => this.onWaveformWheel(e));
        document.querySelectorAll('.tool-btn[data-action], .zoom-btn[data-action]').forEach(btn => btn.addEventListener('click', () => this.executeAction(btn.dataset.action)));
        document.getElementById('cancelExport').addEventListener('click', () => this.closeModal(this.exportModal));
        document.getElementById('confirmExport').addEventListener('click', () => this.exportAudio());
        document.querySelectorAll('.format-btn').forEach(btn => btn.addEventListener('click', (e) => {
          document.querySelectorAll('.format-btn').forEach(b => b.classList.remove('active'));
          e.target.classList.add('active');
          const fmt = e.target.dataset.format;
          document.getElementById('selectedFormat').value = fmt;
          document.getElementById('bitrateGroup').style.display = fmt === 'mp3' ? 'block' : 'none';
          document.getElementById('filenameExt').textContent = '.' + fmt;
        }));
        document.getElementById('exportBitrate').addEventListener('input', (e) => document.getElementById('bitrateValue').textContent = e.target.value + ' kbps');
        document.getElementById('cancelAmplify').addEventListener('click', () => this.closeModal(this.amplifyModal));
        document.getElementById('confirmAmplify').addEventListener('click', () => this.applyAmplify());
        document.getElementById('amplifySlider').addEventListener('input', (e) => document.getElementById('amplifyValue').textContent = e.target.value + ' dB');
        document.getElementById('cancelSilence').addEventListener('click', () => this.closeModal(this.silenceModal));
        document.getElementById('confirmSilence').addEventListener('click', () => this.applyRemoveSilence());
        document.getElementById('silenceThreshold').addEventListener('input', (e) => document.getElementById('thresholdValue').textContent = e.target.value + ' dB');
        document.getElementById('silenceMinDuration').addEventListener('input', (e) => document.getElementById('minDurationValue').textContent = e.target.value + ' ms');
        document.getElementById('silencePadding').addEventListener('input', (e) => document.getElementById('paddingValue').textContent = e.target.value + ' ms');
        this.recordBtn.addEventListener('click', () => this.toggleRecording());
        document.querySelectorAll('.modal-backdrop').forEach(b => b.addEventListener('click', (e) => this.closeModal(e.target.closest('.modal'))));
        document.addEventListener('keydown', (e) => this.handleKeyboard(e));
      }
      closeModal(modal) { modal.classList.remove('active'); }
      initAudioContext() {
        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        this.gainNode = this.audioContext.createGain();
        this.analyserL = this.audioContext.createAnalyser();
        this.analyserR = this.audioContext.createAnalyser();
        this.analyserL.fftSize = 256; this.analyserR.fftSize = 256;
        this.splitter = this.audioContext.createChannelSplitter(2);
        this.gainNode.connect(this.audioContext.destination);
      }
      async loadFile(file) {
        try {
          this.setStatus('Loading...');
          const ab = await file.arrayBuffer();
          this.audioBuffer = await this.audioContext.decodeAudioData(ab);
          this.onAudioLoaded(file.name);
        } catch (e) { this.setStatus('Error: ' + e.message); }
      }
      handleFileSelect(e) { if (e.target.files.length) this.loadFile(e.target.files[0]); }
      loadSample() {
        this.setStatus('Generating sample...');
        const sr = 44100, dur = 20, len = sr * dur;
        this.audioBuffer = this.audioContext.createBuffer(2, len, sr);
        const L = this.audioBuffer.getChannelData(0), R = this.audioBuffer.getChannelData(1);
        const bpm = 128, beatLen = 60 / bpm * sr, sixteenth = beatLen / 4;
        const scale = [65.41, 73.42, 82.41, 87.31, 98.00, 110.00, 123.47, 130.81, 146.83, 164.81, 174.61, 196.00, 220.00, 246.94, 261.63, 293.66, 329.63];
        const chords = [[0, 4, 7, 11], [5, 9, 12, 16], [3, 7, 10, 14], [4, 7, 11, 14]];
        const bassLine = [0, 0, 0, 0, 5, 5, 5, 5, 3, 3, 3, 3, 4, 4, 4, 4];
        const melodyPattern = [12, 12, 14, 12, 11, 11, 9, 11, 12, 14, 16, 14, 12, 11, 9, 7, 12, 11, 12, 14, 16, 14, 12, 11, 9, 7, 9, 11, 12, 9, 7, 4];
        for (let i = 0; i < len; i++) {
          const t = i / sr;
          const beat = Math.floor(i / sixteenth);
          const bar = Math.floor(beat / 16) % 4;
          const measure = Math.floor(beat / 64);
          const noteT = (i % sixteenth) / sixteenth;
          const beatT = (i % beatLen) / beatLen;
          const globalEnv = Math.min(1, t * 0.3) * Math.min(1, (dur - t) * 0.3);
          const intro = Math.min(1, t / 4);
          const chord = chords[bar];
          let pad = 0;
          for (let n = 0; n < chord.length; n++) {
            const freq = scale[chord[n]];
            pad += Math.sin(2 * Math.PI * freq * t) * 0.08;
            pad += Math.sin(2 * Math.PI * freq * 1.002 * t) * 0.04;
          }
          pad *= intro * 0.6;
          const bassFreq = scale[bassLine[beat % 16]];
          const bassEnv = Math.exp(-noteT * 4);
          const bass = Math.sin(2 * Math.PI * bassFreq * t) * 0.4 * bassEnv;
          const subBass = Math.sin(2 * Math.PI * bassFreq / 2 * t) * 0.25 * bassEnv;
          const melodyFreq = scale[melodyPattern[beat % 32]];
          const melodyEnv = Math.exp(-noteT * 5) * (beat % 2 === 0 ? 1 : 0.6);
          const melody = measure >= 1 ? (Math.sin(2 * Math.PI * melodyFreq * t) + Math.sin(4 * Math.PI * melodyFreq * t) * 0.3) * 0.12 * melodyEnv : 0;
          const kickT = beatT;
          const kick = kickT < 0.12 ? Math.sin(2 * Math.PI * (180 - kickT * 1200) * kickT) * Math.exp(-kickT * 30) * 0.7 : 0;
          const snareT = ((i + beatLen / 2) % beatLen) / beatLen;
          const snare = measure >= 1 && snareT < 0.08 ? (Math.random() - 0.5) * Math.exp(-snareT * 40) * 0.35 + Math.sin(2 * Math.PI * 200 * snareT) * Math.exp(-snareT * 50) * 0.2 : 0;
          const hhClosed = noteT < 0.03 ? (Math.random() - 0.5) * Math.exp(-noteT * 80) * 0.12 : 0;
          const ohT = ((i + sixteenth * 2) % beatLen) / beatLen;
          const hhOpen = ohT < 0.06 && beat % 4 === 2 ? (Math.random() - 0.5) * Math.exp(-ohT * 20) * 0.08 : 0;
          const arpNote = scale[(beat * 3) % scale.length + 7];
          const arpEnv = Math.exp(-noteT * 8);
          const arp = measure >= 2 ? Math.sin(2 * Math.PI * arpNote * t) * 0.06 * arpEnv * (beat % 3 === 0 ? 1 : 0.5) : 0;
          const riserProgress = (beat % 64) / 64;
          const riser = bar === 3 && (beat % 16) >= 8 ? Math.sin(2 * Math.PI * (300 + riserProgress * 500) * t) * riserProgress * 0.15 : 0;
          const sample = (pad + bass + subBass + melody + kick + snare + hhClosed + hhOpen + arp + riser) * globalEnv;
          L[i] = Math.tanh(sample * 1.3);
          R[i] = Math.tanh((sample + melody * 0.1 + arp * 0.15 - pad * 0.05) * 1.3);
        }
        this.onAudioLoaded('Electronic Sample.wav');
      }
      onAudioLoaded(fn) {
        this.currentFileName = fn.replace(/\.[^/.]+$/, '');
        this.duration = this.audioBuffer.duration;
        this.playbackPosition = 0; this.playEndPosition = null;
        this.selection = { start: null, end: null };
        this.history = [this.cloneBuffer(this.audioBuffer)];
        this.historyIndex = 0;
        this.emptyState.style.display = 'none';
        this.playhead.style.display = 'block';
        this.waveformArea.classList.add('audio-loaded');
        this.enableControls(true);
        this.updateStatusBar(fn);
        this.drawWaveform(); this.drawRuler();
        this.updateTimeDisplay();
        this.clearSelectionMarkers();
        this.setStatus('Ready');
      }
      enableControls(en) {
        ['playBtn', 'stopBtn', 'skipStartBtn', 'skipEndBtn', 'rewindBtn', 'forwardBtn', 'loopBtn', 'exportBtn', 'normalizeTool', 'reverseTool', 'cropTool', 'fadeInTool', 'fadeOutTool', 'silenceTool', 'amplifyTool', 'removeSilenceTool'].forEach(id => document.getElementById(id).disabled = !en);
        this.updateSelectionTools();
        this.updateHistoryTools();
      }
      updateSelectionTools() {
        const has = this.hasValidSelection();
        ['cutTool', 'copyTool', 'deleteTool'].forEach(id => document.getElementById(id).disabled = !this.audioBuffer || !has);
        document.getElementById('pasteTool').disabled = !this.clipboard;
      }
      hasValidSelection() {
        if (this.selection.start === null || this.selection.end === null) return false;
        return Math.abs(this.selection.end - this.selection.start) * 1000 >= MIN_SELECTION_MS;
      }
      updateHistoryTools() {
        document.getElementById('undoTool').disabled = this.historyIndex <= 0;
        document.getElementById('redoTool').disabled = this.historyIndex >= this.history.length - 1;
      }
      updateStatusBar(fn) {
        document.getElementById('statusFile').textContent = fn || 'No file';
        if (this.audioBuffer) {
          document.getElementById('statusSampleRate').textContent = (this.audioBuffer.sampleRate / 1000).toFixed(1) + ' kHz';
          document.getElementById('statusChannels').textContent = this.audioBuffer.numberOfChannels === 2 ? 'Stereo' : 'Mono';
          document.getElementById('statusDuration').textContent = this.formatTime(this.duration);
        }
      }
      setStatus(m) { document.getElementById('statusMessage').textContent = m; }
      resizeCanvases() {
        const dpr = window.devicePixelRatio || 1;
        const wr = this.waveformArea.getBoundingClientRect();
        this.waveformCanvas.width = wr.width * dpr; this.waveformCanvas.height = wr.height * dpr;
        this.waveformCanvas.style.width = wr.width + 'px'; this.waveformCanvas.style.height = wr.height + 'px';
        this.waveformCtx.scale(dpr, dpr);
        const rr = this.rulerCanvas.parentElement.getBoundingClientRect();
        this.rulerCanvas.width = rr.width * dpr; this.rulerCanvas.height = rr.height * dpr;
        this.rulerCanvas.style.width = rr.width + 'px'; this.rulerCanvas.style.height = rr.height + 'px';
        this.rulerCtx.scale(dpr, dpr);
        if (this.audioBuffer) { this.drawWaveform(); this.drawRuler(); this.updateSelectionMarkers(); }
      }
      drawWaveform() {
        if (!this.audioBuffer) return;
        const w = this.waveformCanvas.width / (window.devicePixelRatio || 1);
        const h = this.waveformCanvas.height / (window.devicePixelRatio || 1);
        const ctx = this.waveformCtx;
        ctx.fillStyle = '#1a1a24'; ctx.fillRect(0, 0, w, h);
        const visDur = this.duration / this.zoom, startT = this.scrollOffset, endT = startT + visDur;
        const startS = Math.floor(startT * this.audioBuffer.sampleRate), endS = Math.ceil(endT * this.audioBuffer.sampleRate);
        const spp = (endS - startS) / w;
        const ld = this.audioBuffer.getChannelData(0);
        const rd = this.audioBuffer.numberOfChannels > 1 ? this.audioBuffer.getChannelData(1) : ld;
        const cy = h / 2;
        ctx.strokeStyle = '#252532'; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(0, cy); ctx.lineTo(w, cy); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, h * 0.25); ctx.lineTo(w, h * 0.25); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, h * 0.75); ctx.lineTo(w, h * 0.75); ctx.stroke();
        for (let ch = 0; ch < 2; ch++) {
          const data = ch === 0 ? ld : rd, yOff = ch === 0 ? -h * 0.25 : h * 0.25;
          ctx.beginPath(); ctx.strokeStyle = ch === 0 ? '#3b9ea8' : '#5bc4ce'; ctx.lineWidth = 1.2;
          for (let x = 0; x < w; x++) {
            const ss = Math.floor(startS + x * spp), se = Math.floor(ss + spp);
            let mn = 1, mx = -1;
            for (let i = ss; i < se && i < data.length; i++) if (i >= 0) { mn = Math.min(mn, data[i]); mx = Math.max(mx, data[i]); }
            ctx.moveTo(x, cy + yOff + mn * h * 0.22); ctx.lineTo(x, cy + yOff + mx * h * 0.22);
          }
          ctx.stroke();
        }
      }
      drawRuler() {
        if (!this.audioBuffer) return;
        const w = this.rulerCanvas.width / (window.devicePixelRatio || 1);
        const h = this.rulerCanvas.height / (window.devicePixelRatio || 1);
        const ctx = this.rulerCtx;
        ctx.fillStyle = '#14141c'; ctx.fillRect(0, 0, w, h);
        const visDur = this.duration / this.zoom, startT = this.scrollOffset, pps = w / visDur;
        let interval = 1;
        if (pps < 8) interval = 15; else if (pps < 15) interval = 10; else if (pps < 30) interval = 5;
        else if (pps < 60) interval = 2; else if (pps < 120) interval = 1; else if (pps < 250) interval = 0.5; else interval = 0.1;
        ctx.fillStyle = '#7a7a8c'; ctx.font = '9px -apple-system,sans-serif'; ctx.textAlign = 'center';
        const first = Math.ceil(startT / interval) * interval;
        for (let t = first; t < startT + visDur; t += interval) {
          const x = (t - startT) / visDur * w;
          ctx.fillStyle = '#2a2a3a'; ctx.fillRect(x, h - 6, 1, 6);
          ctx.fillStyle = '#7a7a8c'; ctx.fillText(this.formatTimeShort(t), x, h - 10);
        }
      }
      clearSelectionMarkers() {
        this.selectionMarkers.forEach(m => m.remove());
        this.selectionMarkers = [];
      }
      updateSelectionMarkers() {
        this.clearSelectionMarkers();
        if (!this.audioBuffer || this.selection.start === null) return;
        const w = this.timelineRuler.getBoundingClientRect().width;
        const visDur = this.duration / this.zoom;
        const s = Math.min(this.selection.start, this.selection.end ?? this.selection.start);
        const e = Math.max(this.selection.start, this.selection.end ?? this.selection.start);
        const x1 = (s - this.scrollOffset) / visDur * w;
        const x2 = (e - this.scrollOffset) / visDur * w;
        if (x1 >= -20 && x1 <= w + 20) {
          const m = document.createElement('div');
          m.className = 'selection-marker'; m.style.left = Math.max(0, Math.min(w, x1)) + 'px';
          m.textContent = this.formatTimeShort(s);
          this.timelineRuler.appendChild(m); this.selectionMarkers.push(m);
        }
        if (this.hasValidSelection() && Math.abs(x2 - x1) > 50 && x2 >= -20 && x2 <= w + 20) {
          const m = document.createElement('div');
          m.className = 'selection-marker'; m.style.left = Math.max(0, Math.min(w, x2)) + 'px';
          m.textContent = this.formatTimeShort(e);
          this.timelineRuler.appendChild(m); this.selectionMarkers.push(m);
        }
      }
      formatTime(s) {
        const m = Math.floor(s / 60), sec = s % 60;
        return m.toString().padStart(2, '0') + ':' + Math.floor(sec).toString().padStart(2, '0') + '.' + Math.floor((sec % 1) * 1000).toString().padStart(3, '0');
      }
      formatTimeShort(s) {
        const m = Math.floor(s / 60), sec = s % 60;
        return m + ':' + sec.toFixed(sec < 10 && m === 0 ? 2 : 1).padStart(sec < 10 ? 4 : 3, '0');
      }
      updateTimeDisplay() {
        this.timeCurrent.textContent = this.formatTime(this.playbackPosition);
        this.timeTotal.textContent = this.formatTime(this.duration);
      }
      updatePlayhead() {
        if (!this.audioBuffer) return;
        const visDur = this.duration / this.zoom;
        const rel = (this.playbackPosition - this.scrollOffset) / visDur;
        const w = this.waveformArea.getBoundingClientRect().width;
        this.playhead.style.left = (rel * w) + 'px';
        this.playhead.style.display = rel >= 0 && rel <= 1 ? 'block' : 'none';
      }
      updateSelection() {
        if (this.selection.start === null) { this.selectionEl.style.display = 'none'; this.updateSelectionMarkers(); return; }
        if (!this.hasValidSelection()) {
          this.selectionEl.style.display = 'none';
          this.updateSelectionMarkers();
          return;
        }
        const w = this.waveformArea.getBoundingClientRect().width, visDur = this.duration / this.zoom;
        const x1 = (Math.min(this.selection.start, this.selection.end) - this.scrollOffset) / visDur * w;
        const x2 = (Math.max(this.selection.start, this.selection.end) - this.scrollOffset) / visDur * w;
        this.selectionEl.style.left = Math.max(0, x1) + 'px';
        this.selectionEl.style.width = (Math.min(w, x2) - Math.max(0, x1)) + 'px';
        this.selectionEl.style.display = 'block';
        this.updateSelectionTools();
        this.updateSelectionMarkers();
      }
      onWaveformMouseDown(e) {
        if (!this.audioBuffer || e.target !== this.waveformCanvas) return;
        const rect = this.waveformArea.getBoundingClientRect(), x = e.clientX - rect.left;
        const visDur = this.duration / this.zoom;
        const clickT = Math.max(0, Math.min(this.duration, this.scrollOffset + (x / rect.width) * visDur));
        const wasPlaying = this.isPlaying;
        if (wasPlaying) this.stopCurrentPlayback();
        if (e.shiftKey && this.selection.start !== null) {
          this.selection.end = clickT;
        } else {
          this.selection.start = clickT; this.selection.end = null; this.isSelecting = true;
        }
        this.playbackPosition = clickT;
        this.updateSelection(); this.updatePlayhead(); this.updateTimeDisplay();
        if (wasPlaying) this.play();
      }
      onWaveformMouseMove(e) {
        if (!this.isSelecting || !this.audioBuffer) return;
        const rect = this.waveformArea.getBoundingClientRect(), x = e.clientX - rect.left;
        const visDur = this.duration / this.zoom;
        this.selection.end = Math.max(0, Math.min(this.duration, this.scrollOffset + (x / rect.width) * visDur));
        this.updateSelection();
      }
      onWaveformMouseUp() {
        if (this.isSelecting) {
          this.isSelecting = false;
          if (this.selection.end !== null && !this.hasValidSelection()) {
            this.selection.end = null;
          }
          if (this.selection.end === null) this.selection.start = this.playbackPosition;
          this.updateSelection();
        }
      }
      onWaveformWheel(e) {
        e.preventDefault();
        if (e.ctrlKey || e.metaKey) { this.setZoom(this.zoom * (e.deltaY > 0 ? 0.92 : 1.08)); }
        else {
          const visDur = this.duration / this.zoom;
          this.scrollOffset = Math.max(0, Math.min(this.duration - visDur, this.scrollOffset + (e.deltaX || e.deltaY) * visDur * 0.001));
          this.drawWaveform(); this.drawRuler(); this.updatePlayhead(); this.updateSelection();
        }
      }
      setZoom(v) {
        this.zoom = Math.max(1, Math.min(50, v));
        document.getElementById('zoomLevel').textContent = this.zoom.toFixed(1) + 'x';
        const visDur = this.duration / this.zoom;
        this.scrollOffset = Math.max(0, Math.min(this.duration - visDur, this.scrollOffset));
        this.drawWaveform(); this.drawRuler(); this.updatePlayhead(); this.updateSelection();
      }
      setVolume(v) {
        this.volume = Math.max(0, Math.min(1, v));
        if (this.gainNode) this.gainNode.gain.value = this.volume;
        this.volumeLevel.textContent = Math.round(this.volume * 100) + '%';
      }
      adjustVolume(delta) {
        this.setVolume(this.volume + delta);
      }
      stopCurrentPlayback() {
        if (this.sourceNode) { try { this.sourceNode.onended = null; this.sourceNode.stop(); } catch (e) { } this.sourceNode = null; }
        this.isPlaying = false;
      }
      togglePlay() {
        if (this.audioContext.state === 'suspended') this.audioContext.resume();
        if (this.isPlaying) this.pause(); else this.play();
      }
      play() {
        if (!this.audioBuffer) return;
        this.stopCurrentPlayback();
        this.sourceNode = this.audioContext.createBufferSource();
        this.sourceNode.buffer = this.audioBuffer;
        this.sourceNode.connect(this.splitter);
        if (this.audioBuffer.numberOfChannels === 1) {
          this.splitter.connect(this.analyserL, 0);
          this.splitter.connect(this.analyserR, 0);
        } else {
          this.splitter.connect(this.analyserL, 0);
          this.splitter.connect(this.analyserR, 1);
        }
        this.sourceNode.connect(this.gainNode);
        let startPos = this.playbackPosition, endPos = this.duration;
        if (this.hasValidSelection()) {
          const selS = Math.min(this.selection.start, this.selection.end);
          const selE = Math.max(this.selection.start, this.selection.end);
          if (this.playbackPosition < selS || this.playbackPosition >= selE) startPos = selS;
          endPos = selE;
          if (this.isLooping) { this.sourceNode.loop = true; this.sourceNode.loopStart = selS; this.sourceNode.loopEnd = selE; }
        } else if (this.isLooping) {
          this.sourceNode.loop = true; this.sourceNode.loopStart = 0; this.sourceNode.loopEnd = this.duration;
        }
        this.playbackPosition = startPos;
        this.playEndPosition = this.isLooping ? null : endPos;
        this.startTime = this.audioContext.currentTime - startPos;
        const playDur = this.isLooping ? undefined : (endPos - startPos);
        this.sourceNode.start(0, startPos, playDur);
        this.sourceNode.onended = () => {
          if (this.isPlaying && !this.isLooping) {
            this.isPlaying = false;
            this.playbackPosition = this.hasValidSelection() ? Math.min(this.selection.start, this.selection.end) : 0;
            this.updatePlayButton(); this.updatePlayhead(); this.updateTimeDisplay();
          }
        };
        this.isPlaying = true; this.updatePlayButton();
      }
      pause() { if (!this.isPlaying) return; this.playbackPosition = this.audioContext.currentTime - this.startTime; this.stopCurrentPlayback(); this.updatePlayButton(); }
      stop() {
        this.stopCurrentPlayback();
        this.playbackPosition = this.hasValidSelection() ? Math.min(this.selection.start, this.selection.end) : 0;
        this.updatePlayhead(); this.updateTimeDisplay(); this.updatePlayButton();
      }
      updatePlayButton() {
        document.getElementById('playIcon').innerHTML = this.isPlaying ? '<rect x="6" y="5" width="4" height="14"/><rect x="14" y="5" width="4" height="14"/>' : '<path d="M8 5v14l11-7z"/>';
      }
      skipToStart() {
        const was = this.isPlaying; this.stopCurrentPlayback();
        this.playbackPosition = 0; this.scrollOffset = 0;
        this.updatePlayhead(); this.updateTimeDisplay(); this.drawWaveform(); this.drawRuler(); this.updateSelectionMarkers();
        if (was) this.play();
      }
      skipToEnd() {
        this.stopCurrentPlayback();
        this.playbackPosition = this.duration;
        const visDur = this.duration / this.zoom;
        this.scrollOffset = Math.max(0, this.duration - visDur);
        this.updatePlayhead(); this.updateTimeDisplay(); this.drawWaveform(); this.drawRuler(); this.updateSelectionMarkers();
      }
      seekRelative(d) {
        const was = this.isPlaying; this.stopCurrentPlayback();
        this.playbackPosition = Math.max(0, Math.min(this.duration, this.playbackPosition + d));
        this.updatePlayhead(); this.updateTimeDisplay();
        if (was) this.play();
      }
      toggleLoop() {
        this.isLooping = !this.isLooping;
        this.loopBtn.classList.toggle('active', this.isLooping);
        if (this.isPlaying) {
          this.playbackPosition = this.audioContext.currentTime - this.startTime;
          if (this.playbackPosition > this.duration) this.playbackPosition = this.playbackPosition % this.duration;
          this.stopCurrentPlayback();
          this.play();
        }
      }
      selectAll() {
        if (!this.audioBuffer) return;
        this.selection.start = 0; this.selection.end = this.duration;
        this.updateSelection();
      }
      handleKeyboard(e) {
        if (e.target.tagName === 'INPUT') return;
        if (e.code === 'Escape') {
          if (this.exportModal.classList.contains('active')) this.closeModal(this.exportModal);
          if (this.amplifyModal.classList.contains('active')) this.closeModal(this.amplifyModal);
          if (this.silenceModal.classList.contains('active')) this.closeModal(this.silenceModal);
          return;
        }
        const k = e.code;
        if (k === 'Space') { e.preventDefault(); this.togglePlay(); }
        else if (k === 'Home') this.skipToStart();
        else if (k === 'End') this.skipToEnd();
        else if (k === 'ArrowLeft') this.seekRelative(-1);
        else if (k === 'ArrowRight') this.seekRelative(1);
        else if (k === 'Equal' || k === 'NumpadAdd') this.setZoom(this.zoom * 1.15);
        else if (k === 'Minus' || k === 'NumpadSubtract') this.setZoom(this.zoom / 1.15);
        else if (k === 'KeyL') this.toggleLoop();
        else if (k === 'KeyC' && (e.ctrlKey || e.metaKey)) this.executeAction('copy');
        else if (k === 'KeyC') this.executeAction('crop');
        else if (k === 'KeyX' && (e.ctrlKey || e.metaKey)) this.executeAction('cut');
        else if (k === 'KeyV' && (e.ctrlKey || e.metaKey)) this.executeAction('paste');
        else if (k === 'KeyZ' && (e.ctrlKey || e.metaKey)) { e.shiftKey ? this.redo() : this.undo(); }
        else if (k === 'Delete' || k === 'Backspace') this.executeAction('delete');
        else if (k === 'KeyI') this.executeAction('fadeIn');
        else if (k === 'KeyO') this.executeAction('fadeOut');
        else if (k === 'KeyN') this.executeAction('normalize');
        else if (k === 'KeyR') this.executeAction('reverse');
        else if (k === 'KeyA' && (e.ctrlKey || e.metaKey)) { e.preventDefault(); this.selectAll(); }
        else if (k === 'KeyA') this.executeAction('amplify');
      }
      getOrSelectAll() {
        if (this.hasValidSelection()) return this.getSelectionRange();
        return { startSample: 0, endSample: this.audioBuffer.length, startTime: 0, endTime: this.duration };
      }
      executeAction(action) {
        if (!this.audioBuffer && !['zoomIn', 'zoomOut'].includes(action)) return;
        switch (action) {
          case 'zoomIn': this.setZoom(this.zoom * 1.25); break;
          case 'zoomOut': this.setZoom(this.zoom / 1.25); break;
          case 'undo': this.undo(); break;
          case 'redo': this.redo(); break;
          case 'cut': this.cutSelection(); break;
          case 'copy': this.copySelection(); break;
          case 'paste': this.pasteClipboard(); break;
          case 'delete': this.deleteSelection(); break;
          case 'crop': this.cropToSelection(); break;
          case 'fadeIn': this.applyFadeIn(); break;
          case 'fadeOut': this.applyFadeOut(); break;
          case 'normalize': this.applyNormalize(); break;
          case 'reverse': this.applyReverse(); break;
          case 'silence': this.applySilence(); break;
          case 'amplify': this.showAmplifyModal(); break;
          case 'removeSilence': this.showSilenceModal(); break;
        }
      }
      getSelectionRange() {
        if (!this.hasValidSelection()) return null;
        const s = Math.min(this.selection.start, this.selection.end), e = Math.max(this.selection.start, this.selection.end);
        return { startSample: Math.floor(s * this.audioBuffer.sampleRate), endSample: Math.floor(e * this.audioBuffer.sampleRate), startTime: s, endTime: e };
      }
      saveToHistory() {
        this.history = this.history.slice(0, this.historyIndex + 1);
        this.history.push(this.cloneBuffer(this.audioBuffer));
        this.historyIndex++;
        if (this.history.length > 50) { this.history.shift(); this.historyIndex--; }
        this.updateHistoryTools();
      }
      undo() {
        if (this.historyIndex > 0) {
          this.historyIndex--;
          this.audioBuffer = this.cloneBuffer(this.history[this.historyIndex]);
          this.duration = this.audioBuffer.duration;
          this.refreshAfterEdit(); this.setStatus('Undo');
        }
      }
      redo() {
        if (this.historyIndex < this.history.length - 1) {
          this.historyIndex++;
          this.audioBuffer = this.cloneBuffer(this.history[this.historyIndex]);
          this.duration = this.audioBuffer.duration;
          this.refreshAfterEdit(); this.setStatus('Redo');
        }
      }
      cloneBuffer(b) {
        const n = this.audioContext.createBuffer(b.numberOfChannels, b.length, b.sampleRate);
        for (let c = 0; c < b.numberOfChannels; c++) n.copyToChannel(b.getChannelData(c).slice(), c);
        return n;
      }
      refreshAfterEdit() {
        this.selection = { start: null, end: null };
        this.playbackPosition = Math.min(this.playbackPosition, this.duration);
        this.drawWaveform(); this.drawRuler(); this.updatePlayhead(); this.updateSelection(); this.updateTimeDisplay(); this.updateHistoryTools();
      }
      cutSelection() {
        const r = this.getSelectionRange(); if (!r) return;
        this.saveToHistory();
        this.clipboard = this.extractRegion(r.startSample, r.endSample);
        this.deleteRegion(r.startSample, r.endSample);
        this.refreshAfterEdit(); this.setStatus('Cut');
        document.getElementById('pasteTool').disabled = false;
      }
      copySelection() {
        const r = this.getSelectionRange(); if (!r) return;
        this.clipboard = this.extractRegion(r.startSample, r.endSample);
        this.setStatus('Copied');
        document.getElementById('pasteTool').disabled = false;
      }
      pasteClipboard() {
        if (!this.clipboard) return;
        this.saveToHistory();
        const pos = Math.floor(this.playbackPosition * this.audioBuffer.sampleRate);
        const newLen = this.audioBuffer.length + this.clipboard.length;
        const nb = this.audioContext.createBuffer(this.audioBuffer.numberOfChannels, newLen, this.audioBuffer.sampleRate);
        for (let c = 0; c < this.audioBuffer.numberOfChannels; c++) {
          const od = this.audioBuffer.getChannelData(c), cd = this.clipboard.getChannelData(Math.min(c, this.clipboard.numberOfChannels - 1)), nd = nb.getChannelData(c);
          nd.set(od.subarray(0, pos), 0); nd.set(cd, pos); nd.set(od.subarray(pos), pos + cd.length);
        }
        this.audioBuffer = nb; this.duration = this.audioBuffer.duration;
        this.refreshAfterEdit(); this.setStatus('Pasted');
      }
      deleteSelection() {
        const r = this.getSelectionRange(); if (!r) return;
        this.saveToHistory();
        this.deleteRegion(r.startSample, r.endSample);
        this.refreshAfterEdit(); this.setStatus('Deleted');
      }
      extractRegion(ss, se) {
        const len = se - ss, b = this.audioContext.createBuffer(this.audioBuffer.numberOfChannels, len, this.audioBuffer.sampleRate);
        for (let c = 0; c < this.audioBuffer.numberOfChannels; c++) b.copyToChannel(this.audioBuffer.getChannelData(c).subarray(ss, se), c);
        return b;
      }
      deleteRegion(ss, se) {
        const newLen = this.audioBuffer.length - (se - ss);
        const nb = this.audioContext.createBuffer(this.audioBuffer.numberOfChannels, Math.max(1, newLen), this.audioBuffer.sampleRate);
        for (let c = 0; c < this.audioBuffer.numberOfChannels; c++) {
          const od = this.audioBuffer.getChannelData(c), nd = nb.getChannelData(c);
          nd.set(od.subarray(0, ss), 0); nd.set(od.subarray(se), ss);
        }
        this.audioBuffer = nb; this.duration = this.audioBuffer.duration;
      }
      cropToSelection() {
        const r = this.getOrSelectAll();
        this.saveToHistory();
        this.audioBuffer = this.extractRegion(r.startSample, r.endSample);
        this.duration = this.audioBuffer.duration;
        this.playbackPosition = 0; this.scrollOffset = 0;
        this.refreshAfterEdit(); this.setStatus('Cropped (kept selection only)');
      }
      applyFadeIn() {
        const r = this.getOrSelectAll();
        this.saveToHistory();
        for (let c = 0; c < this.audioBuffer.numberOfChannels; c++) {
          const d = this.audioBuffer.getChannelData(c), len = r.endSample - r.startSample;
          for (let i = r.startSample; i < r.endSample; i++) d[i] *= Math.pow((i - r.startSample) / len, 2);
        }
        this.drawWaveform(); this.setStatus('Fade in');
      }
      applyFadeOut() {
        const r = this.getOrSelectAll();
        this.saveToHistory();
        for (let c = 0; c < this.audioBuffer.numberOfChannels; c++) {
          const d = this.audioBuffer.getChannelData(c), len = r.endSample - r.startSample;
          for (let i = r.startSample; i < r.endSample; i++) d[i] *= Math.pow(1 - (i - r.startSample) / len, 2);
        }
        this.drawWaveform(); this.setStatus('Fade out');
      }
      applyNormalize() {
        const r = this.getOrSelectAll();
        this.saveToHistory();
        let max = 0;
        for (let c = 0; c < this.audioBuffer.numberOfChannels; c++) {
          const d = this.audioBuffer.getChannelData(c);
          for (let i = r.startSample; i < r.endSample; i++) max = Math.max(max, Math.abs(d[i]));
        }
        if (max > 0) {
          const g = 0.99 / max;
          for (let c = 0; c < this.audioBuffer.numberOfChannels; c++) {
            const d = this.audioBuffer.getChannelData(c);
            for (let i = r.startSample; i < r.endSample; i++) d[i] *= g;
          }
        }
        this.drawWaveform(); this.setStatus('Normalized');
      }
      applyReverse() {
        const r = this.getOrSelectAll();
        this.saveToHistory();
        for (let c = 0; c < this.audioBuffer.numberOfChannels; c++) {
          const d = this.audioBuffer.getChannelData(c);
          const section = d.subarray(r.startSample, r.endSample);
          section.reverse();
        }
        this.drawWaveform(); this.setStatus('Reversed');
      }
      applySilence() {
        const r = this.getOrSelectAll();
        this.saveToHistory();
        for (let c = 0; c < this.audioBuffer.numberOfChannels; c++) {
          const d = this.audioBuffer.getChannelData(c);
          for (let i = r.startSample; i < r.endSample; i++) d[i] = 0;
        }
        this.drawWaveform(); this.setStatus('Silenced');
      }
      showAmplifyModal() {
        document.getElementById('amplifySlider').value = 0;
        document.getElementById('amplifyValue').textContent = '0 dB';
        this.amplifyModal.classList.add('active');
      }
      applyAmplify() {
        const r = this.getOrSelectAll();
        this.saveToHistory();
        const db = parseFloat(document.getElementById('amplifySlider').value), g = Math.pow(10, db / 20);
        for (let c = 0; c < this.audioBuffer.numberOfChannels; c++) {
          const d = this.audioBuffer.getChannelData(c);
          for (let i = r.startSample; i < r.endSample; i++) d[i] = Math.max(-1, Math.min(1, d[i] * g));
        }
        this.closeModal(this.amplifyModal);
        this.drawWaveform(); this.setStatus('Amplified ' + db + ' dB');
      }
      showExportModal() {
        if (!this.audioBuffer) return;
        document.getElementById('exportFilename').value = this.currentFileName || 'audio';
        document.querySelectorAll('.format-btn').forEach(b => b.classList.remove('active'));
        document.querySelector('.format-btn[data-format="wav"]').classList.add('active');
        document.getElementById('selectedFormat').value = 'wav';
        document.getElementById('filenameExt').textContent = '.wav';
        document.getElementById('bitrateGroup').style.display = 'none';
        this.exportModal.classList.add('active');
      }
      async exportAudio() {
        const fn = document.getElementById('exportFilename').value || 'audio-export';
        const fmt = document.getElementById('selectedFormat').value;
        this.setStatus('Exporting...');
        try {
          let blob, ext;
          const bitrate = parseInt(document.getElementById('exportBitrate').value);
          switch (fmt) {
            case 'mp3':
              blob = this.encodeMP3(this.audioBuffer, bitrate);
              ext = 'mp3';
              break;
            case 'flac':
              blob = await this.encodeFLAC(this.audioBuffer);
              ext = 'flac';
              break;
            default:
              blob = this.encodeWAV(this.audioBuffer);
              ext = 'wav';
          }
          const url = URL.createObjectURL(blob), a = document.createElement('a');
          a.href = url; a.download = fn + '.' + ext; a.click();
          URL.revokeObjectURL(url);
          this.closeModal(this.exportModal);
          this.setStatus('Exported: ' + fn + '.' + ext);
        } catch (e) { this.setStatus('Export error: ' + e.message); console.error(e); }
      }
      encodeWAV(buf) {
        const nc = buf.numberOfChannels, sr = buf.sampleRate, bd = 16, bps = bd / 8, ba = nc * bps;
        const dl = buf.length * ba, bl = 44 + dl;
        const ab = new ArrayBuffer(bl), v = new DataView(ab);
        const ws = (o, s) => { for (let i = 0; i < s.length; i++) v.setUint8(o + i, s.charCodeAt(i)); };
        ws(0, 'RIFF'); v.setUint32(4, bl - 8, true); ws(8, 'WAVE'); ws(12, 'fmt ');
        v.setUint32(16, 16, true); v.setUint16(20, 1, true); v.setUint16(22, nc, true);
        v.setUint32(24, sr, true); v.setUint32(28, sr * ba, true); v.setUint16(32, ba, true); v.setUint16(34, bd, true);
        ws(36, 'data'); v.setUint32(40, dl, true);
        const chs = []; for (let c = 0; c < nc; c++) chs.push(buf.getChannelData(c));
        let o = 44;
        for (let i = 0; i < buf.length; i++) {
          for (let c = 0; c < nc; c++) {
            const s = Math.max(-1, Math.min(1, chs[c][i]));
            v.setInt16(o, s < 0 ? s * 0x8000 : s * 0x7FFF, true); o += 2;
          }
        }
        return new Blob([ab], { type: 'audio/wav' });
      }
      encodeMP3(buf, bitrate) {
        const nc = buf.numberOfChannels, sr = buf.sampleRate, len = buf.length;
        const mp3enc = new lamejs.Mp3Encoder(nc, sr, bitrate);
        const mp3Data = [];
        const sampleBlockSize = 1152;
        const left = buf.getChannelData(0);
        const right = nc > 1 ? buf.getChannelData(1) : left;
        const leftInt = new Int16Array(len);
        const rightInt = new Int16Array(len);
        for (let i = 0; i < len; i++) {
          leftInt[i] = Math.max(-32768, Math.min(32767, Math.floor(left[i] * 32767)));
          rightInt[i] = Math.max(-32768, Math.min(32767, Math.floor(right[i] * 32767)));
        }
        for (let i = 0; i < len; i += sampleBlockSize) {
          const leftChunk = leftInt.subarray(i, Math.min(i + sampleBlockSize, len));
          const rightChunk = rightInt.subarray(i, Math.min(i + sampleBlockSize, len));
          const mp3buf = nc > 1 ? mp3enc.encodeBuffer(leftChunk, rightChunk) : mp3enc.encodeBuffer(leftChunk);
          if (mp3buf.length > 0) mp3Data.push(mp3buf);
        }
        const mp3End = mp3enc.flush();
        if (mp3End.length > 0) mp3Data.push(mp3End);
        return new Blob(mp3Data, { type: 'audio/mp3' });
      }
      async encodeFLAC(buf) {
        return new Promise((resolve, reject) => {
          try {
            if (typeof Flac === 'undefined') {
              reject(new Error('FLAC encoder not loaded'));
              return;
            }
            Flac.onready = () => {
              const encoder = Flac.create_libflac_encoder(buf.sampleRate, buf.numberOfChannels, 16, 5);
              if (!encoder) {
                reject(new Error('Failed to create FLAC encoder'));
                return;
              }
              const flacData = [];
              const writeCallback = (buffer, bytes) => {
                flacData.push(new Uint8Array(buffer.slice(0, bytes)));
              };
              Flac.init_encoder_stream(encoder, writeCallback);
              const left = buf.getChannelData(0);
              const right = buf.numberOfChannels > 1 ? buf.getChannelData(1) : left;
              const samples = new Int32Array(left.length * buf.numberOfChannels);
              for (let i = 0; i < left.length; i++) {
                samples[i * buf.numberOfChannels] = Math.floor(left[i] * 32767);
                if (buf.numberOfChannels > 1) {
                  samples[i * buf.numberOfChannels + 1] = Math.floor(right[i] * 32767);
                }
              }
              Flac.FLAC__stream_encoder_process_interleaved(encoder, samples, left.length);
              Flac.FLAC__stream_encoder_finish(encoder);
              Flac.FLAC__stream_encoder_delete(encoder);
              const blob = new Blob(flacData, { type: 'audio/flac' });
              resolve(blob);
            };
            if (Flac.isReady()) Flac.onready();
          } catch (e) {
            reject(e);
          }
        });
      }
      showSilenceModal() {
        document.getElementById('silenceThreshold').value = -40;
        document.getElementById('thresholdValue').textContent = '-40 dB';
        document.getElementById('silenceMinDuration').value = 500;
        document.getElementById('minDurationValue').textContent = '500 ms';
        document.getElementById('silencePadding').value = 50;
        document.getElementById('paddingValue').textContent = '50 ms';
        this.silenceModal.classList.add('active');
      }
      applyRemoveSilence() {
        const thresholdDb = parseFloat(document.getElementById('silenceThreshold').value);
        const minDurationMs = parseFloat(document.getElementById('silenceMinDuration').value);
        const paddingMs = parseFloat(document.getElementById('silencePadding').value);
        const threshold = Math.pow(10, thresholdDb / 20);
        const sr = this.audioBuffer.sampleRate;
        const minSamples = Math.floor(minDurationMs * sr / 1000);
        const paddingSamples = Math.floor(paddingMs * sr / 1000);
        const windowSize = Math.floor(sr * 0.02);
        this.saveToHistory();
        const channels = [];
        for (let c = 0; c < this.audioBuffer.numberOfChannels; c++) {
          channels.push(this.audioBuffer.getChannelData(c));
        }
        const getRMS = (start, end) => {
          let sum = 0, count = 0;
          for (let i = start; i < end && i < channels[0].length; i++) {
            for (let c = 0; c < channels.length; c++) {
              sum += channels[c][i] * channels[c][i];
              count++;
            }
          }
          return count > 0 ? Math.sqrt(sum / count) : 0;
        };
        const silentRegions = [];
        let silentStart = null;
        for (let i = 0; i < channels[0].length; i += windowSize) {
          const rms = getRMS(i, i + windowSize);
          const isSilent = rms < threshold;
          if (isSilent && silentStart === null) {
            silentStart = i;
          } else if (!isSilent && silentStart !== null) {
            if (i - silentStart >= minSamples) {
              const start = Math.min(channels[0].length, silentStart + paddingSamples);
              const end = Math.max(0, i - paddingSamples);
              if (end > start) silentRegions.push({ start, end });
            }
            silentStart = null;
          }
        }
        if (silentStart !== null && channels[0].length - silentStart >= minSamples) {
          const start = Math.min(channels[0].length, silentStart + paddingSamples);
          if (channels[0].length > start) silentRegions.push({ start, end: channels[0].length });
        }
        if (silentRegions.length === 0) {
          this.closeModal(this.silenceModal);
          this.setStatus('No silence regions found');
          return;
        }
        const keep = [];
        let pos = 0;
        for (const region of silentRegions) {
          if (region.start > pos) keep.push({ start: pos, end: region.start });
          pos = region.end;
        }
        if (pos < channels[0].length) keep.push({ start: pos, end: channels[0].length });
        if (keep.length === 0 || keep.reduce((s, r) => s + (r.end - r.start), 0) === 0) {
          this.closeModal(this.silenceModal);
          this.setStatus('Cannot remove all audio');
          return;
        }
        let newLen = 0;
        keep.forEach(r => newLen += r.end - r.start);
        const nb = this.audioContext.createBuffer(this.audioBuffer.numberOfChannels, newLen, sr);
        for (let c = 0; c < this.audioBuffer.numberOfChannels; c++) {
          const od = this.audioBuffer.getChannelData(c);
          const nd = nb.getChannelData(c);
          let writePos = 0;
          for (const region of keep) {
            nd.set(od.subarray(region.start, region.end), writePos);
            writePos += region.end - region.start;
          }
        }
        this.audioBuffer = nb;
        this.duration = this.audioBuffer.duration;
        this.closeModal(this.silenceModal);
        this.refreshAfterEdit();
        this.setStatus('Removed ' + silentRegions.length + ' silent region(s)');
      }
      async toggleRecording() {
        if (this.isRecording) {
          this.stopRecording();
        } else {
          await this.startRecording();
        }
      }
      async startRecording() {
        try {
          if (this.audioContext.state === 'suspended') await this.audioContext.resume();
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          this.recordedChunks = [];
          this.recordingStartTime = Date.now();
          this.mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
          this.mediaRecorder.ondataavailable = (e) => {
            if (e.data.size > 0) this.recordedChunks.push(e.data);
          };
          this.mediaRecorder.onstop = async () => {
            stream.getTracks().forEach(t => t.stop());
            if (this.recordingSource) {
              this.recordingSource.disconnect();
              this.recordingSource = null;
            }
            const blob = new Blob(this.recordedChunks, { type: 'audio/webm' });
            const ab = await blob.arrayBuffer();
            this.audioBuffer = await this.audioContext.decodeAudioData(ab);
            this.onAudioLoaded('recording');
          };
          this.recordingSource = this.audioContext.createMediaStreamSource(stream);
          this.recordingSource.connect(this.analyserL);
          this.recordingSource.connect(this.analyserR);
          const overlay = document.createElement('div');
          overlay.className = 'recording-overlay';
          const indicator = document.createElement('div');
          indicator.className = 'recording-indicator';
          const circle = document.createElement('div');
          circle.className = 'recording-circle';
          const timer = document.createElement('div');
          timer.className = 'recording-timer';
          timer.id = 'recordingTimer';
          timer.textContent = '00:00.000';
          indicator.appendChild(circle);
          indicator.appendChild(timer);
          const stopBtn = document.createElement('button');
          stopBtn.className = 'btn recording';
          stopBtn.textContent = 'Stop Recording';
          stopBtn.addEventListener('click', () => this.stopRecording());
          overlay.appendChild(indicator);
          overlay.appendChild(stopBtn);
          document.body.appendChild(overlay);
          this.recordingOverlay = overlay;
          this.stopRecordingBtn = stopBtn;
          this.recordingTimerEl = timer;
          this.mediaRecorder.start(100);
          this.isRecording = true;
          this.updateRecordingTimer();
          this.setStatus('Recording...');
        } catch (e) {
          this.setStatus('Microphone access denied');
          console.error(e);
        }
      }
      updateRecordingTimer() {
        if (!this.isRecording || !this.recordingTimerEl) return;
        const elapsed = (Date.now() - this.recordingStartTime) / 1000;
        this.recordingTimerEl.textContent = this.formatTime(elapsed);
        requestAnimationFrame(() => this.updateRecordingTimer());
      }
      stopRecording() {
        if (this.mediaRecorder && this.mediaRecorder.state !== 'inactive') {
          this.mediaRecorder.stop();
        }
        this.isRecording = false;
        if (this.recordingSource) {
          this.recordingSource.disconnect();
          this.recordingSource = null;
        }
        if (this.recordingOverlay) {
          this.recordingOverlay.remove();
          this.recordingOverlay = null;
        }
        this.stopRecordingBtn = null;
        this.recordingTimerEl = null;
        this.recordBtn.classList.remove('recording');
        this.recordBtn.textContent = 'Record';
        this.setStatus('Processing recording...');
      }
      animate() {
        if (this.isPlaying) {
          const newPos = this.audioContext.currentTime - this.startTime;
          if (this.isLooping && this.hasValidSelection()) {
            const selS = Math.min(this.selection.start, this.selection.end);
            const selE = Math.max(this.selection.start, this.selection.end);
            const selLen = selE - selS;
            this.playbackPosition = selS + ((newPos - selS) % selLen);
            if (this.playbackPosition < selS) this.playbackPosition += selLen;
          } else if (this.isLooping) {
            this.playbackPosition = newPos % this.duration;
          } else {
            this.playbackPosition = newPos;
          }
          if (this.playEndPosition && this.playbackPosition >= this.playEndPosition) {
            this.stopCurrentPlayback();
            this.playbackPosition = this.hasValidSelection() ? Math.min(this.selection.start, this.selection.end) : 0;
            this.updatePlayButton();
          }
          this.updatePlayhead(); this.updateTimeDisplay();
          const visDur = this.duration / this.zoom;
          if (this.playbackPosition > this.scrollOffset + visDur * 0.9 || this.playbackPosition < this.scrollOffset) {
            this.scrollOffset = Math.max(0, Math.min(this.duration - visDur, this.playbackPosition - visDur * 0.1));
            this.drawWaveform(); this.drawRuler(); this.updateSelection();
          }
        }
        this.updateVUMeters();
        requestAnimationFrame(() => this.animate());
      }
      updateVUMeters() {
        if (!this.isPlaying && !this.isRecording) {
          this.peakL *= 0.92; this.peakR *= 0.92;
          this.vuLeft.style.width = '0'; this.vuRight.style.width = '0';
          this.vuPeakLeft.style.left = (this.peakL * 100) + '%';
          this.vuPeakRight.style.left = (this.peakR * 100) + '%';
          return;
        }
        const bl = this.analyserL.frequencyBinCount;
        const dL = new Uint8Array(bl), dR = new Uint8Array(bl);
        this.analyserL.getByteFrequencyData(dL); this.analyserR.getByteFrequencyData(dR);
        let sL = 0, sR = 0;
        for (let i = 0; i < bl; i++) { sL += dL[i]; sR += dR[i]; }
        const aL = sL / bl / 255, aR = sR / bl / 255;
        const dbL = aL > 0 ? Math.max(0, 1 + Math.log10(aL) / 1.5) : 0;
        const dbR = aR > 0 ? Math.max(0, 1 + Math.log10(aR) / 1.5) : 0;
        this.vuLeft.style.width = (dbL * 100) + '%';
        this.vuRight.style.width = (dbR * 100) + '%';
        if (dbL > this.peakL) this.peakL = dbL; else this.peakL *= this.peakDecay;
        if (dbR > this.peakR) this.peakR = dbR; else this.peakR *= this.peakDecay;
        this.vuPeakLeft.style.left = Math.min(98, this.peakL * 100) + '%';
        this.vuPeakRight.style.left = Math.min(98, this.peakR * 100) + '%';
      }
    }
    window.addEventListener('DOMContentLoaded', () => { window.audioTool = new AudioTool(); });
  </script>
</body>

</html>